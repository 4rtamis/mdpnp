

// OCTETSTRING




//=============================================================================
/**
 * Integer and bit string data types
 *
 * For representing integer numbers, the object definitions use fixed-size data
 * types only. The bit string data types represent a bit field where each
 * single bit has a defined meaning (i.e., flag fields). (See BITS16, BITS32.)
 *
 * Where integer and bit string data types assume values from a fixed set of
 * possibilities, enums may define the set of values. This implements an enum
 * naming scheme. For bit string types, the name of the associated enum assumes
 * the name of the bit string type with the postfix "Bits". Enumeration values
 * represent the number of places to bit left-shift. If this sounds mysterious
 * see http://www.cprogramming.com/tutorial/bitwise_operators.html for a brief
 * explanation.
 *
 * For integer types the name of the associated enum assumes the name of the
 * integer type with the postfix "Vals". For example, the NomPartition integer
 * type is defined as INTU16. Variables defined by this type assume values from
 * the set defined by the enum NomPartitionVals.
 *
 * The following integer data types and bit string data types are used:
 */

typedef char CHARSTRING;
typedef octet INTU8;
typedef char INTI8;
typedef unsigned short INTU16;
typedef short INTI16;
typedef unsigned long INTU32;
typedef long INTI32;

typedef INTU16 BITS16;
typedef INTU32 BITS32;

typedef double FLOATType;

#if 1
typedef INTU8 OCTETSTRING;
#else
struct OCTETSTRING
{
  INTU16  length;    
  INTU8   value[1];
};
#endif


//#define STRING_T string

//=============================================================================
/**
 * Identification data type
 * All elements (e.g., classes, objects, measurement types) that need unique
 * identification are assigned an OID. The set of valid OIDs for this standard
 * is defined in ISO/IEEE 11073-10101. The nomenclature is split into a set of
 * partitions, and each partition has its own range of 16-bit codes. In other
 * words, the 16-bit code is context-sensitive.
 */


/**
 * Private OID
 * For IDs that are not part of the standard nomenclature (i.e., private or
 * manufacturer-specific codes), a special type is defined:
 */
typedef INTU16 PrivateOID;

//=============================================================================
/**
 * Handle data type
 * The handle data type is used for efficient, locally unique identification of
 * all managed medical object instances. (Locally unique means unique within
 * one MDS context.)
 */


//=============================================================================
/**
 * Instance number data type
 * Use the instance number data type to distinguish class or object instances
 * of the same type or object instances that are not directly manageable (i.e.,
 * used, e.g., as the Name Binding attribute for Operation objects).
 */
typedef INTU16 InstNumber;

//=============================================================================
/**
 * Global object identification
 * Handle and instance number data types must be unique inside one specific
 * naming context (e.g., handles are unique within at least one MDS context).
 * This uniqueness allows the identification of an object instance within its
 * naming context by one single, small identifier.
 *
 * To address larger scale systems, a context ID field at the MDS level within
 * an MDIB is added to the handle data type so that multiple device systems
 * can be distinguished.
 *
 * MDS Context ID
 */
typedef INTU16 MdsContext;

/**
 * Global handle identifies an object in a larger scale system.
 */
struct GLBHANDLE
{
  MdsContext context_id;
  DIMHANDLE  dimhandle;
}; //@top-level false

/**
 * Managed OID as a type for complete global object identification.
 */
struct ManagedObjectId
{
  OIDType   m_obj_class;
  GLBHANDLE m_obj_inst;
}; //@top-level false

/**
 * Example: A medical device may interface with further medical devices (i.e.,
 * sub-devices). In the MDIB, this device may model these sub-devices as
 * individual MDS objects with their own naming context. In this way, name
 * space collisions (e.g., duplicate handle values, duplicate nomenclature
 * codes) can be avoided without reassigning handle values. A manager system
 * needs to interpret the MDS context IDs together with handle values to
 * uniquely identify object instances within this composite MDIB. The context
 * IDs are assigned when the MDIB is created by Context Scanner object create
 * notifications.
 *
 * Assumptions and possible restrictions about different naming contexts within
 * an MDIB are profile dependent.
 */

//=============================================================================
/**
 * Type ID data type
 * The type ID data type is used in the VMOs and VMS objects to provide
 * specific static information about the type of an object instance (e.g.,
 * blood pressure could be the type of a Numeric object). Codes defined in the
 * nomenclature are used. The nomenclature contains a number of partitions, and
 * code values are unique only within one partition. As the type ID data type
 * should be context-free, the partition of the nomenclature code is also
 * provided.
 */





/**
 * Type ID
 */


//=============================================================================
/**
 * Relative time data type
 * The relative time data type is a high-resolution time definition relative to
 * some event (e.g., a synchronization event at startup). Use this data type to
 * position events relative to each other.
 *
 * Relative time has a resolution of 125 microseconds [least significant bit],
 * which is sufficient for sampling rates up to 8 kHz and spans time periods up
 * to 6.2 days.
 *
 * Note that the time accuracy is defined by the system itself.
 */
typedef INTU32 RelativeTime;

//=============================================================================
/**
 * High-resolution relative time data type
 * If either the resolution or the time span of the previously defined relative
 * time data type is not sufficient, a high-resolution relative time data type
 * is defined. The data type is 64 bits long. If there is no 64-bit integer
 * data type defined, an opaque (i.e., string) data structure is used.
 */
typedef unsigned long long HighResRelativeTime;
/*
typedef INTU8 HighResRelativeTime[8];
*/

//=============================================================================
/**
 * Absolute Time
 * Use the Absolute Time data type whenever data is time stamped and a
 * resolution of 1s is sufficient.
 */
struct AbsoluteTime
{
  INTU8 century;  /// Zero-based. For year 2012, century = 20 (not 21)
  INTU8 year;     /// For 2012, year = 12
  INTU8 month;    /// 1 - 12
  INTU8 day;      /// 1 - 31
  INTU8 hour;
  INTU8 minute;
  INTU8 second;
  INTU8 sec_fractions;  /// hundredths of second
}; //@top-level false

//=============================================================================
/**
 * Date data type
 * The date data type is used to specify a certain calendar date.
 */
struct Date
{
  INTU8 century;  /// Zero-based. For year 2012, century = 20 (not 21)
  INTU8 year;
  INTU8 month;
  INTU8 day;
}; //@top-level false

//=============================================================================
/**
 * Operational state data type
 * The operational state data type defines if a certain object or other
 * property is enabled or disabled.
 */
typedef INTU16 OperationalState;  /// @see OperationalStateVals



//=============================================================================
/**
 * Administrative state data type
 * The administrative state data type defines if a certain object is locked or
 * unlocked.
 */
typedef INTU16 AdministrativeState;  /// @see AdministrativeStateVals



//=============================================================================
/**
 * System-Model attribute is specified by manufacturer and
 * manufacturer-specific model number.
 */
struct SystemModel
{
  CHARSTRING manufacturer[MAXSTRSIZE_LABEL];
  CHARSTRING model_number[MAXSTRSIZE_LABEL];
}; //@top-level false

//=============================================================================
/**
 * Production-Specification attribute deals with serial numbers, part numbers,
 * revisions. A device may have multiple components so the
 * Production-Specification attribute should be a printable string defining the
 * component and the "number".
 */

/**
 * Production-Specification Entry.
 */
struct ProdSpecEntry
{
  INTU16 spec_type;	  /// @see ProdSpecTypeVals
  PrivateOID  component_id;
  CHARSTRING prod_spec[MAXSTRSIZE_LABEL];
}; //@top-level false



struct ProductionSpec
{
  INTU16  count;
  ProdSpecEntry value[MAX_PRODSPECENTRIES];
}; //@top-level false





struct MetricStructure {
  MetricStructureType ms_struct;
  INTU8 ms_comp_no;
}; //@top-level false



struct MetricCalEntry {
  MetricCalType cal_type;
  MetricCalState cal_state;
  AbsoluteTime cal_time;
}; //@top-level false

typedef sequence<MetricCalEntry, 256> MetricCalibration;

struct MetricSpec
{
  RelativeTime update_period;
  MetricCategory category;
  MetricAccess access;
  MetricStructure structure;
  MetricRelevance relevance;
}; //@top-level false

struct object_attribute {
  long object_id;
  long attribute_id;
  sequence<octet, 65536> value;
};



//=============================================================================
/**
 * Attribute Value Assertion (AVA)
 * Object attributes, represented as data record structures, contain an
 * identifier for the attribute, a length field for parsing and the actual
 * attribute value. The attribute record is the Attribute Value Assertion.
 */
struct AVAType
{
  OIDType  attribute_id;
  INTU16   length;
  INTU16   attribute_val;
}; //@top-level false

//=============================================================================
/**
 * Attribute List
 * This type, provided for convenience, defines a list of attributes.
 */
struct AttributeList
{
  INTU16  count;
  INTU16  length;
  AVAType value[1];
}; //@top-level false

//=============================================================================
/**
 * Color data type represents the basic RGB colors.
 */
typedef INTU16 SimpleColor;  /// @see SimpleColorVals



//=============================================================================
/**
 * CharSet
 * Charset names correspond to Internet Assigned Numbers Authority (IANA), the
 * numeral constants are the IANA MIBenum values for registered charsets.
 */
typedef INTU16 CharSet;  /// @see CharSetVals



//=============================================================================
typedef BITS16 StringFlags;  /// @see StringFlagsBits

enum StringFlagsBits
{
  str_flag_nt  = 0x1  // 0  /// strings are null terminated
};

//=============================================================================
struct StringSpec
{
  INTU16 str_max_len;
  StringFlags str_flags;
}; //@top-level false

//=============================================================================
/**
 * Locale data type.
 * Use the locale data type to specify language and encoding information for
 * data types that represent human-readable text strings.
 */
struct Locale
{
  INTU32  language;
  INTU32  country;
  CharSet charset;
  StringSpec str_spec;
}; //@top-level false

//=============================================================================
/**
 * Alert-Op-State attribute defines the current limit alert state
 * NOTE--The bits refer to the limit alarm only, not to the global alert
 * state of the metric
 */
typedef BITS16 CurLimAlStat;  /// @see CurLimAlStatBits

enum CurLimAlStatBits
{
  lim_alert_off = 0x1, // 0,  /// if this bit set all alerts (both high, low) are off
  lim_low_off   = 0x2, // 1,  /// low-limit violation detection is off
  lim_high_off  = 0x4  // 2   /// high-limit violation detection is off
};

//=============================================================================
/**
 * Current-Limits attribute
 */
struct CurLimAlVal
{
  FLOATType lower;
  FLOATType upper;
}; //@top-level false

//=============================================================================
/**
 * Top object.
 * The Top object is the common inheritance base for all objects in the DIM.
 */
valuetype DIMT_Top {
  /// Define the ID of the class.
  /// IDs come from the object-oriented nomenclature partition.
  public OIDType  class_id; //@key

  /// Define ID of Name Binding attribute, e.g., DIMHANDLE.
  /// IDs come from the object-oriented nomenclature partition.
  public OIDType  name_binding_id; //@key
};

//=============================================================================
/**
 * Virtual Medical Object (VMO).
 * The VMO is the base class for all medical-related objects in the model.
 * The VMO provides consistent naming and identification across the Medical
 * Package model.
 */
valuetype DIMT_VMO : DIMT_Top
{
  /// Define a specific static type of this object, as defined in the
  /// object-oriented or metric nomenclature partition.
  public TTYPE object_type; //@key

  /// Locally unique short-hand identification.
  public DIMHANDLE dimhandle; //@key

  /// Text representation of type ID.
  public CHARSTRING label_string[MAXSTRSIZE_LABEL]; 

  // external object relations?
}; 

struct ExtNomenRef {
  OIDType nomenclature_id;
  // the type of nomenclature_code is ANY DEFINED BY nomenclature_id in ASN.1
  // I do not know the best way to represent that.
  INTU16 nomenclature_code;
}; //@top-level false

typedef sequence<OIDType, 256> SiteList;
typedef sequence<ExtNomenRef, 256> SiteListEx;
typedef sequence<OIDType, 256> MetricSourceList;

struct VmoSourceEntry {
  OIDType vmo_type;
  GLBHANDLE glb_handle;
}; //@top-level false

typedef sequence<VmoSourceEntry, 256> VmoSourceList;


struct MetricMeasure {
  FLOATType value;
  OIDType unit_code;
}; //@top-level false

valuetype DIMT_Metric : DIMT_VMO
{
  // the only mandatory metric field
  public MetricSpec metricSpecn;

  public RelativeTime max_delay_time;
  public MetricStatus metric_status;
  public MeasurementStatus measurement_status;
  public NomPartition metric_id_partition;
  public OIDType metric_id;
  public ExtNomenRef metric_id_ext;
  public OIDType unit_code;
  public OCTETSTRING unit_labelstring;
  public VmoSourceList vmo_source_list;
  public MetricSourceList metric_source_list;
  public SiteList msmt_site_list;
  public SiteListEx msmt_site_list_ex;
  public SiteList body_site_list;
  public SiteListEx body_site_list_ex;
  public MetricCalibration metric_calibration;
  public SimpleColor color;
  public PrivateOID measure_mode;
  public MetricMeasure measure_period;
  public MetricMeasure averaging_period;
  public AbsoluteTime start_time;
  public AbsoluteTime stop_time;
  public OCTETSTRING metric_info_labelstring;
  public ExtNomenRef substance;
  public OCTETSTRING substance_labelstring;
  
};



//=============================================================================
/**
 * MetricStatus and MeasurementStatus are used in several medical package objs.
 * Maybe define these in a separate file?
 */

/**
 * Metric-Status
 */
typedef BITS16 MetricStatus;   /// @see MetricStatusBits

enum MetricStatusBits
{
  metric_off  = 0x1,  // 0,
  metric_not_ready  = 0x2,  // 1,
  metric_standby  = 0x4,    // 2,
  metric_transduc_discon  = 0x100,  // 8,
  metric_hw_discon  = 0x200 // 9
};

/**
 * MeasurementStatus defines the state of the measurement
 */
typedef BITS16 MeasurementStatus;    /// @see MeasurementStatusBits.

enum MeasurementStatusBits
{
  ms_invalid              = 0x01,   // 0,
  ms_questionable         = 0x02,   // 1,
  ms_unavailable          = 0x04,   // 2,
  ms_calibration_ongoing  = 0x08,   // 3,
  ms_test_data            = 0x10,   // 4,
  ms_demo_data            = 0x20,   // 5,
  ms_validated_data       = 0x100,  // 8,   /// relevant, e.g., in an archive
  ms_early_indication     = 0x200,  // 9,   /// early estimate of value
  ms_msmt_ongoing         = 0x400,  // 10,  /// new measurement is being taken
  ms_msmt_in_state_alarm  = 0x4000, // 14,  /// metric has active alarm cond

  /// metric supports alarming, and alarms are turned off
  ms_msmt_state_al_inhibited = 0x8000 // 15
};
