/**
 * @file    dim_attrgrp_obsval_nu.idl
 * @author  WMS
 * @brief   Define objects for the metric numeric obs value attribute group.
 *
 * This specifies a set of data types in OMG IDL format. Top-level data types
 * model data samples that DDS publishes and subscribes via a shared a DDS
 * Topic. IDL is a language-independent description language, and a standard
 * component of both the DDS and CORBA specifications. This file serves as
 * input to the RTI code generator rtiddsgen. It parses the IDL file and
 * automatically generates all the necessary routines and wrapper functions to
 * bind the types for use by Connext at run time. You will end up with a set of
 * required routines and structures that your application and Connext use to
 * manipulate the data.
 *
 * @note    This uses custom directives specific to rtiddsgen, the RTI code
 * generator. Custom directives start with //@. Some structures declared in
 * this file use the directive
 *
 * //@top-level false
 *
 * This indicates that you do not intend to create a DDS Topic to publish or
 * subscribe to the associated data type. rtiddsgen will not generate type-
 * specific methods used by DataWriters and DataReaders to send and receive
 * data of that type. rtiddsgen will still generate code to serialize and
 * deserialize the type data, since they may be embedded in top-level types.
 * See section 3.3.8 Using Custom Directives in the RTI Connext Core
 * Libraries and Utilities User's Manual, v 5.0.
 *
 * @note   The prefix DTI = Data Type Interface. Objects with prefix DTI_
 * are intended to associate with a DDS Topic. Topic names have prefix TOPIC_.
 *
 * @see RTI Connext Core Libraries and Utilities User's Manual, v 5.0, August
 * 2012 <www.rti.com>.
 *
 * @see ISO/IEEE 11073-10101 Health informatics - Point-of-care medical device
 * communication - Part 10101: Nomenclature.
 *
 * @see ISO/IEEE 11073-10201 Health informatics - Point-of-care medical device
 * communication - Part 10201: Domain information model.
 *
 * @see MDC_ATTR_GRP_METRIC_VAL_OBS, 11073-10201, Table 7.12.
 */
//=============================================================================

module ice {


/**
 * The following constant definitions will be available in the generated code
 * as macros. If you use #define in an IDL file, the preprocessor will
 * substitute the value before generating the code and make this symbol
 * unavailable in the program.
 */
const long MAX_COMPOUND_NUOBSVAL_ENTRIES  = 10;

//=============================================================================
/**
 * Integer and bit string data types
 *
 * For representing integer numbers, the object definitions use fixed-size data
 * types only. The bit string data types represent a bit field where each
 * single bit has a defined meaning (i.e., flag fields). (See BITS16, BITS32.)
 *
 * Where integer and bit string data types assume values from a fixed set of
 * possibilities, enums may define the set of values. This implements an enum
 * naming scheme. For bit string types, the name of the associated enum assumes
 * the name of the bit string type with the postfix "Bits". The 11073
 * documentation represents bit enumerators as the number of places to bit
 * left-shift. But this implements bit enumerators as the actual value
 * represented as hex values that you can use directly as masks/flags.
 *
 * For non-bit string integer types the name of the associated enum assumes the
 * name of the integer type with the postfix "Vals". For example, the
 * NomPartition integer type is defined as INTU16. Variables defined by this
 * type assume values from the enum NomPartitionVals.
 *
 * The model uses the following data types.
 */

typedef octet INTU8;
typedef INTU8 INTU8BCD; /// For byte types with BCD encoding
typedef octet INTI8;
typedef unsigned short INTU16;
typedef short INTI16;
typedef unsigned long INTU32;
typedef long INTI32;

typedef INTU16 BITS16;
typedef INTU32 BITS32;

typedef double FLOATType;

//=============================================================================
/**
 * Identification data type
 * All elements (e.g., classes, objects, measurement types) that need unique
 * identification are assigned an OID. The set of valid OIDs for this standard
 * is defined in ISO/IEEE 11073-10101. The nomenclature is split into a set of
 * partitions, and each partition has its own range of 16-bit codes. In other
 * words, the 16-bit code is context-sensitive.
 */
typedef INTU16 OIDType;

//=============================================================================
/**
 * Handle data type
 * The handle data type is used for efficient, locally unique identification of
 * all managed medical object instances. (Locally unique means unique within
 * one MDS context.)
 */
typedef INTU16 DIMHANDLE;

//=============================================================================
/**
 * Global object identification
 * Handle and instance number data types must be unique inside one specific
 * naming context (e.g., handles are unique within at least one MDS context).
 * This uniqueness allows the identification of an object instance within its
 * naming context by one single, small identifier.
 *
 * To address larger scale systems, a context ID field at the MDS level within
 * an MDIB is added to the handle data type so that multiple device systems
 * can be distinguished.
 */

/**
 * MDS Context ID
 */
typedef INTU16 MDSContext;

/**
 * Example: A medical device may interface with further medical devices (i.e.,
 * sub-devices). In the MDIB, this device may model these sub-devices as
 * individual MDS objects with their own naming context. In this way, name
 * space collisions (e.g., duplicate handle values, duplicate nomenclature
 * codes) can be avoided without reassigning handle values. A manager system
 * needs to interpret the MDS context IDs together with handle values to
 * uniquely identify object instances within this composite MDIB. The context
 * IDs are assigned when the MDIB is created by Context Scanner object create
 * notifications.
 *
 * Assumptions and possible restrictions about different naming contexts within
 * an MDIB are profile dependent.
 */

//=============================================================================
/**
 * Relative time data type
 * The relative time data type is a high-resolution time definition relative to
 * some event (e.g., a synchronization event at startup). Use this data type to
 * position events relative to each other.
 *
 * Relative time has a resolution of 125 microseconds [least significant bit],
 * which is sufficient for sampling rates up to 8 kHz and spans time periods up
 * to 6.2 days.
 *
 * Note that the time accuracy is defined by the system itself.
 */
typedef INTU32 RelativeTime;

//=============================================================================
/**
 * Absolute Time
 * Use the Absolute Time data type whenever data are time stamped and a
 * resolution of 1s is sufficient. For efficiency, the values in the structure
 * are BCD-encoded (i.e., 4-bit nibbles). The year 1993, for example, is
 * represented by the hexadecimal value 0x19 in the century field and the hex
 * value 0x93 in the year field.
 */
struct AbsoluteTime
{
  INTU8BCD century;  /// Zero-based.
  INTU8BCD year;
  INTU8BCD month;    /// 1-based
  INTU8BCD day;      /// 1-based
  INTU8BCD hour;     /// 24-hour representation
  INTU8BCD minute;
  INTU8BCD second;
  INTU8BCD sec_fractions;  /// hundredths of second

}; //@top-level false

//=============================================================================
/**
 * Metric-Status
 * @see MetricStatusBits
 */
typedef BITS16 MetricStatus;

enum MetricStatusBits
{
  metric_off  = 0x01,  /// 0,
  metric_not_ready  = 0x02,  /// 1,
  metric_standby    = 0x04,  /// 2,
  metric_transduc_discon  = 0x0100,  /// 8,
  metric_hw_discon  = 0x0200  /// 9
};

/**
 * MeasurementStatus defines the state of the measurement
 * @see MeasurementStatusBits.
 */
typedef BITS16 MeasurementStatus;

/// @see MeasurementStatus
enum MeasurementStatusBits
{
  /// 11073 excludes the ms_ prefix.
  ms_invalid              = 0x01,   /// 0,
  ms_questionable         = 0x02,   /// 1,
  ms_unavailable          = 0x04,   /// 2,
  ms_calibration_ongoing  = 0x08,   /// 3,
  ms_test_data            = 0x10,   /// 4,
  ms_demo_data            = 0x20,   /// 5,
  ms_validated_data       = 0x100,   /// 8, relevant, e.g., in an archive
  ms_early_indication     = 0x200,   /// 9, early estimate of value
  ms_msmt_ongoing         = 0x400,   /// 10, new measurement is being taken
  ms_msmt_in_state_alarm  = 0x4000,  /// 14, metric has active alarm cond
  ms_msmt_state_al_inhibited = 0x8000  /// 15, metric supports alarming, and
                                       /// alarms are turned off
};

typedef INTU16 NomPartition;  /// @see NomPartitionVals

/**
 * @see NomPartition
 */
enum NomPartitionVals
{
  /// These nomenclature partitions exist.
  nom_part_unspec = 0,
  nom_part_obj    = 1,  /// object-oriented partition
  nom_part_metric = 2,  /// metric [supervisory control and data acquisition
                        /// (SCADA)] partition
  nom_part_alert  = 3,  /// alerts/events partition
  nom_part_dim    = 4,  /// dimensions partition
  nom_part_vattr  = 5,  /// virtual attribute partition for Operation objects
  nom_part_pgrp   = 6,  /// parameter group ID partition
  nom_part_sites  = 7,  /// measurement and body site locations
  nom_part_infrastruct  = 8,   /// infrastructure elements partition
  nom_part_fef  = 9,        /// file exchange format partition
  nom_part_ecg_extn = 10,   /// ECG extensions partition
  nom_part_ext_nom  = 256,  /// IDs of other nomenclatures and dictionaries
  nom_part_priv     = 1024  /// private partition
};

//=============================================================================
/**
 * Type ID data type
 * The type ID data type is used in the VMO and VMS objects to provide
 * specific static information about the type of an object instance (e.g.,
 * blood pressure could be the type of a Numeric object). Codes defined in the
 * nomenclature are used. The nomenclature contains a number of partitions, and
 * code values are unique only within one partition. As the type ID data type
 * should be context-free, the partition of the nomenclature code is also
 * provided.
 */
struct TTYPE
{
  NomPartition partition;
  OIDType code;

}; //@top-level false

//=============================================================================
/*
 * Numeric object
 * The Numeric object represents numerical measurements and status information,
 * e.g., amplitude measures, counters.
 *
 * Example: A heart rate measurement is represented by a Numeric object.
 */

/**
 * Numeric Observed Value
 * MDC_ATTR_NU_VAL_OBS (2384)
 *
 * The Numeric Observed Value represents the (measured) value, state and
 * identification data.
 */
struct NuObsValue
{
  /// From VMO::Type or Metric-Id-Partition partition.
  OIDType metric_id;

  /// Bit string defines the state of the measurement.
  MeasurementStatus state;

  /// From dimensions nomenclature partition.
  OIDType unit_code;

  FLOATType value;

}; //@top-level false

/**
 * Compound Numeric Observed Value
 * MDC_ATTR_NU_CMPD_VAL_OBS (2379)
 *
 * Used when multiple values are represented in a single Numeric object.
 * (Structure is compound.)
 */
struct NuObsValueCmp
{
  sequence<NuObsValue, MAX_COMPOUND_NUOBSVAL_ENTRIES> values;

}; //@top-level false

/**
 * Metric observed value group, numeric object class attributes
 * MDC_ATTR_GRP_METRIC_VAL_OBS (2051)
 */
struct DTI_MDC_ATTR_GRP_METRIC_VAL_OBS_Numeric
{
  /// Which MDS?
  MDSContext context_id; //@key

  /// Handle of the reported numeric, unique within the containing device.
  /// Renamed from (11073) "handle" to avoid conflict.
  DIMHANDLE dimhandle; //@key

  /// Identify the nomenclature partition associated with the metric_id if
  /// different from the partition specified in object's VMO::Type attribute.
  NomPartition metric_id_partition;

  /// Time of observation.
  AbsoluteTime absolute_timestamp;

  /// The represented measurement value(s).
  /// This implements the general case, using compound numeric for both
  /// multiple AND single values.
  NuObsValueCmp nu_obs_value_cmp;

}; //@top-level true

const string TOPIC_AG_METRIC_VAL_OBS_NU =
  "TOPIC_MDC_ATTR_GRP_METRIC_VAL_OBS_Numeric";

};