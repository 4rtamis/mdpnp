/**
 * @file    dim_attrgrp_obsval_nu.idl
 * @author  WMS
 * @brief   Define objects for the metric numeric obs value attribute group.
 *
 * @note    As much as possible this adheres to the ISO/IEEE 11073
 * nomenenclature and domain information model specification referenced below.
 * This may define non-conforming common objects, and, if so, adds the prefix
 * ICE_ to their names, and/or explains them with articulate, concise,
 * meaningful and heartfelt comments.
 *
 * @note    This uses custom directives specific to rtiddsgen, the RTI code
 * generator. Custom directives start with //@. Some structures declared in
 * this file use the directive
 *
 *    //@top-level false
 *
 * This indicates that you do not intend to create a DDS Topic to publish or
 * subscribe to the associated data type. rtiddsgen will not generate type-
 * specific methods used by DataWriters and DataReaders to send and receive
 * data of that type. rtiddsgen will still generate code to serialize and
 * deserialize the type data, since they may be embedded in top-level types.
 * See section 3.3.8 Using Custom Directives in the RTI Connext Core
 * Libraries and Utilities User's Manual, v 5.0.
 * 
 * @see RTI Connext Core Libraries and Utilities User's Manual, v 5.0, August
 * 2012 <www.rti.com>.
 *
 * @see ISO/IEEE 11073-10101 Health informatics - Point-of-care medical device
 * communication - Part 10101: Nomenclature.
 *
 * @see ISO/IEEE 11073-10201 Health informatics - Point-of-care medical device
 * communication - Part 10201: Domain information model.
 *
 * @see MDC_ATTR_GRP_METRIC_VAL_OBS, 11073-10201, Table 7.12.
 */
//=============================================================================

// Uncomment this to make available ICE non-conformant timestamp
#define ICE_NONCONFORMANT_TIMESTAMP_AVAILABLE

/**
 * The following constant definitions will be available in the generated code
 * as macros. If you use #define in an IDL file, the preprocessor will
 * substitute the value before generating the code, making this symbol 
 * unavailable in the program.
 */
const long MAX_COMPOUND_NUOBSVAL_ENTRIES  = 10;

//=============================================================================
/**
 * Integer and bit string data types
 *
 * For representing integer numbers, the object definitions use fixed-size data
 * types only. The bit string data types represent a bit field where each
 * single bit has a defined meaning (i.e., flag fields). (See BITS16, BITS32.)
 *
 * Where integer and bit string data types assume values from a fixed set of
 * possibilities, enums may define the set of values. This implements an enum
 * naming scheme. For bit string types, the name of the associated enum assumes
 * the name of the bit string type with the postfix "Bits". The 11073
 * documentation represents bit enumerators as the number of places to bit 
 * left-shift. But this implements bit enumerators as the actual value
 * represented as hex values that you can use directly as masks/flags.
 *
 * For non-bit string integer types the name of the associated enum assumes the
 * name of the integer type with the postfix "Vals". For example, the
 * NomPartition integer type is defined as INTU16. Variables defined by this
 * type assume values from the set defined by the enum NomPartitionVals.
 *
 * The model uses the following data types.
 */

typedef octet INTU8;
typedef octet INTI8;
typedef unsigned short INTU16;
typedef short INTI16;
typedef unsigned long INTU32;
typedef long INTI32;

typedef INTU16 BITS16;
typedef INTU32 BITS32;

typedef double FLOATType;

//=============================================================================
/**
 * Identification data type
 * All elements (e.g., classes, objects, measurement types) that need unique
 * identification are assigned an OID. The set of valid OIDs for this standard
 * is defined in ISO/IEEE 11073-10101. The nomenclature is split into a set of
 * partitions, and each partition has its own range of 16-bit codes. In other
 * words, the 16-bit code is context-sensitive.
 */
typedef INTU16 OIDType;

//=============================================================================
/**
 * Handle data type
 * The handle data type is used for efficient, locally unique identification of
 * all managed medical object instances. (Locally unique means unique within
 * one MDS context.)
 */
typedef INTU16 DIMHANDLE;

//=============================================================================
/**
 * Global object identification
 * Handle and instance number data types must be unique inside one specific
 * naming context (e.g., handles are unique within at least one MDS context).
 * This uniqueness allows the identification of an object instance within its
 * naming context by one single, small identifier.
 *
 * To address larger scale systems, a context ID field at the MDS level within
 * an MDIB is added to the handle data type so that multiple device systems
 * can be distinguished.
 */

/**
 * MDS Context ID
 */
typedef INTU16 MDSContext;

/**
 * Example: A medical device may interface with further medical devices (i.e.,
 * sub-devices). In the MDIB, this device may model these sub-devices as
 * individual MDS objects with their own naming context. In this way, name
 * space collisions (e.g., duplicate handle values, duplicate nomenclature
 * codes) can be avoided without reassigning handle values. A manager system
 * needs to interpret the MDS context IDs together with handle values to
 * uniquely identify object instances within this composite MDIB. The context
 * IDs are assigned when the MDIB is created by Context Scanner object create
 * notifications.
 *
 * Assumptions and possible restrictions about different naming contexts within
 * an MDIB are profile dependent.
 */

//=============================================================================
/**
 * Relative time data type
 * The relative time data type is a high-resolution time definition relative to
 * some event (e.g., a synchronization event at startup). Use this data type to
 * position events relative to each other.
 *
 * Relative time has a resolution of 125 microseconds [least significant bit],
 * which is sufficient for sampling rates up to 8 kHz and spans time periods up
 * to 6.2 days.
 *
 * Note that the time accuracy is defined by the system itself.
 */
typedef INTU32 RelativeTime;

//=============================================================================
/**
 * Absolute Time
 * Use the Absolute Time data type whenever data are time stamped and a
 * resolution of 1s is sufficient. For efficiency, the values in the structure
 * are BCD-encoded (i.e., 4-bit nibbles). The year 1993, for example, is
 * represented by the hexadecimal value 0x19 in the century field and the hex
 * value 0x93 in the year field.
 */
struct AbsoluteTime
{
  INTU8 century;  /// Zero-based.
  INTU8 year;
  INTU8 month;    /// 1-based
  INTU8 day;      /// 1-based
  INTU8 hour;     /// 24-hour representation
  INTU8 minute;
  INTU8 second;
  INTU8 sec_fractions;  /// hundredths of second
}; //@top-level false

#ifdef ICE_NONCONFORMANT_TIMESTAMP_AVAILABLE
//=============================================================================
/**
 * ICE time representation.
 *
 * The ICE information model specifies time 
 */

/**
 * ICE Absolute Time
 */
struct ICE_Time_t
{
  INTI32  sec;
  INTU32  nanosec;
}; //@top-level false

typedef ICE_Time_t ICE_AbsoluteTime;

//=============================================================================
/**
 * ICE Relative Time
 */
struct ICE_Duration_t
{
  INTI32  sec;
  INTU32  nanosec;
}; //@top-level false

typedef ICE_Duration_t ICE_RelativeTime;

#endif  // ICE_NONCONFORMANT_TIMESTAMP_AVAILABLE

//=============================================================================
/**
 * Metric-Status
 * @see MetricStatusBits
 */
typedef BITS16 MetricStatus;

enum MetricStatusBits
{
  metric_off  = 0x01,  /// 0,
  metric_not_ready  = 0x02,  /// 1,
  metric_standby    = 0x04,  /// 2,
  metric_transduc_discon  = 0x0100,  /// 8,
  metric_hw_discon  = 0x0200  /// 9
};  //@top-level false  // NOLINT

/**
 * MeasurementStatus defines the state of the measurement
 * @see MeasurementStatusBits.
 */
typedef BITS16 MeasurementStatus;

/// @see MeasurementStatus
enum MeasurementStatusBits
{
  /// 11073 excludes the ms_ prefix.
  ms_invalid              = 0x01,   /// 0,
  ms_questionable         = 0x02,   /// 1,
  ms_unavailable          = 0x04,   /// 2,
  ms_calibration_ongoing  = 0x08,   /// 3,
  ms_test_data            = 0x10,   /// 4,
  ms_demo_data            = 0x20,   /// 5,
  ms_validated_data       = 0x100,   /// 8, relevant, e.g., in an archive
  ms_early_indication     = 0x200,   /// 9, early estimate of value
  ms_msmt_ongoing         = 0x400,   /// 10, new measurement is being taken
  ms_msmt_in_state_alarm  = 0x4000,  /// 14, metric has active alarm cond

  /// metric supports alarming, and alarms are turned off
  ms_msmt_state_al_inhibited = 0x8000  /// 15
};  //@top-level false  // NOLINT

/**
 * Enumerations for non-bit string values.
 * @see NomPartition
 */
enum NomPartition
{
  /// These nomenclature partitions exist.
  nom_part_unspec = 0,
  nom_part_obj    = 1,  /// object-oriented partition
  nom_part_metric = 2,  /// metric [supervisory control and data acquisition
                        /// (SCADA)] partition
  nom_part_alert  = 3,  /// alerts/events partition
  nom_part_dim    = 4,  /// dimensions partition
  nom_part_vattr  = 5,  /// virtual attribute partition for Operation objects
  nom_part_pgrp   = 6,  /// parameter group ID partition
  nom_part_sites  = 7,  /// measurement and body site locations
  nom_part_infrastruct  = 8,   /// infrastructure elements partition
  nom_part_fef  = 9,        /// file exchange format partition
  nom_part_ecg_extn = 10,   /// ECG extensions partition
  nom_part_ext_nom  = 256,  /// IDs of other nomenclatures and dictionaries
  nom_part_priv     = 1024  /// private partition
};

//=============================================================================
/*
 * Numeric object
 * The Numeric object represents numerical measurements and status information,
 * e.g., amplitude measures, counters.
 *
 * Example: A heart rate measurement is represented by a Numeric object.
 */

/**
 * Numeric Observed Value
 * MDC_ATTR_NU_VAL_OBS (2384)
 *
 * The Numeric Observed Value represents the (measured) value, state and
 * identification data.
 */
struct NuObsValue
{
  /// From VMO::Type or Metric-Id-Partition partition.
  OIDType metric_id;

  /// Bit string defines the state of the measurement.
  MeasurementStatus state;

  /// From dimensions nomenclature partition.
  OIDType unit_code;

  FLOATType value;
}; //@top-level false

/**
 * Metric observed value group, numeric object class attributes
 * MDC_ATTR_GRP_METRIC_VAL_OBS (2051)
 *
 * @note   The prefix DTI = Data Type Interface. Objects with prefix DTI_
 * are intended to associate with a DDS Topic. Construct its name by replacing
 * prefix DTI_ with TOPIC_.
 *
 */
struct DTI_MDC_ATTR_GRP_METRIC_VAL_OBS_Numeric
{
  /// Which MDS?
  MDSContext context_id;

  /// Handle of the reported numeric, unique within the containing device.
  /// Renamed from (11073) handle to avoid conflict.
  DIMHANDLE dimhandle;

  NomPartition metric_id_partition;

  /// Time of observation.
#ifdef ICE_NONCONFORMANT_TIMESTAMP_AVAILABLE
  ICE_AbsoluteTime absolute_timestamp;
#else
  AbsoluteTime absolute_timestamp;
#endif

  /// The represented measurement value(s).
  /// This implements the general case. Use compound numeric for both multiple
  /// AND single values.
  sequence<NuObsValue, MAX_COMPOUND_NUOBSVAL_ENTRIES> nu_obs_value_cmp;

}; //@top-level true

