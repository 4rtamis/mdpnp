#ifndef _DIM_BASE_TYPES_IDL_
#define _DIM_BASE_TYPES_IDL_

/**
 * @file    dim_base_types.h
 * @author  WMS
 * @brief   Define a set of common data types used in object definitions for
 *          the 11073 Device Information Model (DIM), assuming a Data
 *          Distribution Service (DDS) implementation.
 *
 * @see ISO/IEEE 11073-10101 Health informatics - Point-of-care medical device
 * communication - Part 10101: Nomenclature
 *
 * @see ISO/IEEE 11073-10201 Health informatics - Point-of-care medical device
 * communication - Part 10201: Domain information model
 *
 * @see ASTM final F-2761 Medical Devices and Medical Systems -
 * Essential safety requirements for equipment comprising the patient-centric
 * integrated clinical environment (ICE) - Part 1: General requirements and
 * conceptual model
 */
//=============================================================================
//@copy-c #pragma once

#include <org/mdpnp/types/denormalized/dim_base_defs.idl>
//#include "dim_base_defs.idl"
//=============================================================================
/**
 * Integer and bit string data types
 *
 * For representing integer numbers, the object definitions use fixed-size data
 * types only. The bit string data types represent a bit field where each
 * single bit has a defined meaning (i.e., flag fields). (See BITS16, BITS32.)
 *
 * Where integer and bit string data types assume values from a fixed set of
 * possibilities, enums may define the set of values. This implements an enum
 * naming scheme. For bit string types, the name of the associated enum assumes
 * the name of the bit string type with the postfix "Bits". Enumeration values
 * represent the number of places to bit left-shift. If this sounds mysterious
 * see http://www.cprogramming.com/tutorial/bitwise_operators.html for a brief
 * explanation.
 *
 * For integer types the name of the associated enum assumes the name of the
 * integer type with the postfix "Vals". For example, the NomPartition integer
 * type is defined as INTU16. Variables defined by this type assume values from
 * the set defined by the enum NomPartitionVals.
 *
 * The following integer data types and bit string data types are used:
 */

module org {
	module mdpnp {
			module types {
				module denormalized {

typedef char CHARSTRING;
typedef octet INTU8;
typedef octet INTI8;
typedef unsigned short INTU16;
typedef short INTI16;
typedef unsigned long INTU32;
typedef long INTI32;

typedef INTU16 BITS16;
typedef INTU32 BITS32;

typedef double FLOATType;

//#if 1
typedef INTU8 OCTETSTRING;
//#else
//struct OCTETSTRING
//{
//  INTU16  length;    
//  INTU8   value[1];
//}; //@top-level false
//#endif


//#define STRING_T string

//=============================================================================
/**
 * Identification data type
 * All elements (e.g., classes, objects, measurement types) that need unique
 * identification are assigned an OID. The set of valid OIDs for this standard
 * is defined in ISO/IEEE 11073-10101. The nomenclature is split into a set of
 * partitions, and each partition has its own range of 16-bit codes. In other
 * words, the 16-bit code is context-sensitive.
 */
typedef INTU16 OIDType;

/**
 * Private OID
 * For IDs that are not part of the standard nomenclature (i.e., private or
 * manufacturer-specific codes), a special type is defined:
 */
typedef INTU16 PrivateOID;

//=============================================================================
/**
 * Handle data type
 * The handle data type is used for efficient, locally unique identification of
 * all managed medical object instances. (Locally unique means unique within
 * one MDS context.)
 */
typedef INTU16 DIMHANDLE;

//=============================================================================
/**
 * Instance number data type
 * Use the instance number data type to distinguish class or object instances
 * of the same type or object instances that are not directly manageable (i.e.,
 * used, e.g., as the Name Binding attribute for Operation objects).
 */
typedef INTU16 InstNumber;

//=============================================================================
/**
 * Global object identification
 * Handle and instance number data types must be unique inside one specific
 * naming context (e.g., handles are unique within at least one MDS context).
 * This uniqueness allows the identification of an object instance within its
 * naming context by one single, small identifier.
 *
 * To address larger scale systems, a context ID field at the MDS level within
 * an MDIB is added to the handle data type so that multiple device systems
 * can be distinguished.
 *
 * MDS Context ID
 */
typedef INTU16 MdsContext;

/**
 * Global handle identifies an object in a larger scale system.
 */
struct GLBHANDLE
{
  MdsContext context_id;
  DIMHANDLE  dimhandle;
}; //@top-level false

/**
 * Managed OID as a type for complete global object identification.
 */
struct ManagedObjectId
{
  OIDType   m_obj_class;
  GLBHANDLE m_obj_inst;
}; //@top-level false

/**
 * Example: A medical device may interface with further medical devices (i.e.,
 * sub-devices). In the MDIB, this device may model these sub-devices as
 * individual MDS objects with their own naming context. In this way, name
 * space collisions (e.g., duplicate handle values, duplicate nomenclature
 * codes) can be avoided without reassigning handle values. A manager system
 * needs to interpret the MDS context IDs together with handle values to
 * uniquely identify object instances within this composite MDIB. The context
 * IDs are assigned when the MDIB is created by Context Scanner object create
 * notifications.
 *
 * Assumptions and possible restrictions about different naming contexts within
 * an MDIB are profile dependent.
 */

//=============================================================================
/**
 * Type ID data type
 * The type ID data type is used in the VMOs and VMS objects to provide
 * specific static information about the type of an object instance (e.g.,
 * blood pressure could be the type of a Numeric object). Codes defined in the
 * nomenclature are used. The nomenclature contains a number of partitions, and
 * code values are unique only within one partition. As the type ID data type
 * should be context-free, the partition of the nomenclature code is also
 * provided.
 */

typedef INTU16 NomPartition;  /// @see NomPartitionVals

/**
 * The following nomenclature partitions exist
 */
enum NomPartitionVals
{
  nom_part_unspec = 0,
  nom_part_obj    = 1,  /// object-oriented partition
  nom_part_metric = 2,  /// metric [supervisory control and data acquisition
                        ///  (SCADA)] partition
  nom_part_alert  = 3,  /// alerts/events partition
  nom_part_dim    = 4,  /// dimensions partition
  nom_part_vattr  = 5,  /// virtual attribute partition for Operation objects
  nom_part_pgrp   = 6,  /// parameter group ID partition
  nom_part_sites  = 7,  /// measurement and body site locations
  nom_part_infrastruct  = 8,    /// infrastructure elements partition
  nom_part_fef  = 9,        /// file exchange format partition
  nom_part_ecg_extn = 10,   /// ECG extensions partition
  nom_part_ext_nom  = 256,  /// IDs of other nomenclatures and dictionaries
  nom_part_priv     = 1024  /// private partition
};

/**
 * Type ID
 */
struct TTYPE
{
  NomPartition partition;
  OIDType code;
}; //@top-level false

//=============================================================================
/**
 * Relative time data type
 * The relative time data type is a high-resolution time definition relative to
 * some event (e.g., a synchronization event at startup). Use this data type to
 * position events relative to each other.
 *
 * Relative time has a resolution of 125 microseconds [least significant bit],
 * which is sufficient for sampling rates up to 8 kHz and spans time periods up
 * to 6.2 days.
 *
 * Note that the time accuracy is defined by the system itself.
 */
typedef INTU32 RelativeTime;

//=============================================================================
/**
 * High-resolution relative time data type
 * If either the resolution or the time span of the previously defined relative
 * time data type is not sufficient, a high-resolution relative time data type
 * is defined. The data type is 64 bits long. If there is no 64-bit integer
 * data type defined, an opaque (i.e., string) data structure is used.
 */
typedef unsigned long long HighResRelativeTime;
/*
typedef INTU8 HighResRelativeTime[8];
*/

//=============================================================================
/**
 * Absolute Time
 * Use the Absolute Time data type whenever data is time stamped and a
 * resolution of 1s is sufficient.
 */
struct AbsoluteTime
{
  INTU8 century;  /// Zero-based. For year 2012, century = 20 (not 21)
  INTU8 year;     /// For 2012, year = 12
  INTU8 month;    /// 1 - 12
  INTU8 day;      /// 1 - 31
  INTU8 hour;
  INTU8 minute;
  INTU8 second;
  INTU8 sec_fractions;  /// hundredths of second
}; //@top-level false

//=============================================================================
/**
 * Date data type
 * The date data type is used to specify a certain calendar date.
 */
struct Date
{
  INTU8 century;  /// Zero-based. For year 2012, century = 20 (not 21)
  INTU8 year;
  INTU8 month;
  INTU8 day;
}; //@top-level false

//=============================================================================
/**
 * Operational state data type
 * The operational state data type defines if a certain object or other
 * property is enabled or disabled.
 */
typedef INTU16 OperationalState;  /// @see OperationalStateVals

enum OperationalStateVals
{
  os_disabled  = 0,
  os_enabled   = 1,
  os_not_available = 2
};

//=============================================================================
/**
 * Administrative state data type
 * The administrative state data type defines if a certain object is locked or
 * unlocked.
 */
typedef INTU16 AdministrativeState;  /// @see AdministrativeStateVals

enum AdministrativeStateVals
{
  as_locked  = 0,
  as_unlocked  = 1,
  as_shutting_down  = 2
};

//=============================================================================
/**
 * System-Model attribute is specified by manufacturer and
 * manufacturer-specific model number.
 */
struct SystemModel
{
  CHARSTRING manufacturer[MAXSTRSIZE_LABEL];
  CHARSTRING model_number[MAXSTRSIZE_LABEL];
}; //@top-level false

//=============================================================================
/**
 * Production-Specification attribute deals with serial numbers, part numbers,
 * revisions. A device may have multiple components so the
 * Production-Specification attribute should be a printable string defining the
 * component and the "number".
 */

/**
 * Production-Specification Entry.
 */
struct ProdSpecEntry
{
  INTU16 spec_type;	  /// @see ProdSpecTypeVals
  PrivateOID  component_id;
  CHARSTRING prod_spec[MAXSTRSIZE_LABEL];
}; //@top-level false

enum ProdSpecTypeVals
{
  ps_unspecified    = 0,
  ps_serial_number  = 1,
  ps_part_number  = 2,
  ps_hw_revision  = 3,
  ps_sw_revision  = 4,
  ps_fw_revision  = 5,
  ps_protocol_revision  = 6
};

struct ProductionSpec
{
  INTU16  count;
  ProdSpecEntry value[MAX_PRODSPECENTRIES];
}; //@top-level false

//=============================================================================
/**
 * Attribute Value Assertion (AVA)
 * Object attributes, represented as data record structures, contain an
 * identifier for the attribute, a length field for parsing and the actual
 * attribute value. The attribute record is the Attribute Value Assertion.
 */
struct AVAType
{
  OIDType  attribute_id;
  INTU16   length;
  INTU16   attribute_val;
}; //@top-level false

//=============================================================================
/**
 * Attribute List
 * This type, provided for convenience, defines a list of attributes.
 */
struct AttributeList
{
  INTU16  count;
  INTU16  length;
  AVAType value[1];
}; //@top-level false

//=============================================================================
/**
 * Color data type represents the basic RGB colors.
 */
typedef INTU16 SimpleColor;  /// @see SimpleColorVals

enum SimpleColorVals
{
  col_black   = 0,
  col_red     = 1,
  col_green   = 2,
  col_yellow  = 3,
  col_blue    = 4,
  col_magenta = 5,
  col_cyan    = 6,
  col_white   = 7
};

//=============================================================================
/**
 * CharSet
 * Charset names correspond to Internet Assigned Numbers Authority (IANA), the
 * numeral constants are the IANA MIBenum values for registered charsets.
 */
typedef INTU16 CharSet;  /// @see CharSetVals

enum CharSetVals
{
  charset_unspec  = 0,
  charset_iso_10646_ucs_2  = 1000,  /// ISO 10646 two-octet character encoding scheme, big endian
  charset_iso_10646_ucs_4  = 1001,  /// ISO 10646 four-octet character encoding scheme, big endian
  charset_iso_8859_1  = 4,  /// encoding according to ISO/IEC 8859 Part 1
  charset_iso_8859_2  = 5,  /// encoding according to ISO/IEC 8859 Part 2
  charset_iso_8859_3  = 6,  /// encoding according to ISO/IEC 8859 Part 3
  charset_iso_8859_4  = 7,  /// encoding according to ISO/IEC 8859 Part 4
  charset_iso_8859_5  = 8,  /// encoding according to ISO/IEC 8859 Part 5
  charset_iso_8859_6  = 9,  /// encoding according to ISO/IEC 8859 Part 6
  charset_iso_8859_7  = 10,  /// encoding according to ISO/IEC 8859 Part 7
  charset_iso_8859_8  = 11,  /// encoding according to ISO/IEC 8859 Part 8
  charset_iso_8859_9  = 12,  /// encoding according to ISO/IEC 8859 Part 9
  charset_iso_8859_10  = 13,  /// encoding according to ISO/IEC 8859 Part 10
  charset_iso_8859_13  = 109,  /// encoding according to ISO/IEC 8859 Part 13
  charset_iso_8859_14  = 110,  /// encoding according to ISO/IEC 8859 Part 14
  charset_iso_8859_15  = 111,  /// encoding according to ISO/IEC 8859 Part 15
  charset_iso_2022_kr  = 37,  /// encoding according to RFC 1557 (Korean Character Encoding)
  charset_ks_c_5601  = 36,  /// encoding according to Korean Industrial Standard, KSC 5601-1987
  charset_iso_2022_jp  = 39,  /// encoding according to RFC 1468 (Japanese Character Encoding)
  charset_iso_2022_jp_2  = 40,  /// encoding according to RFC 1554 (Japanese Character Encoding)
  charset_jis_x0208  = 63,  /// encoding according to JIS X0208:1983,1990
  charset_iso_2022_cn  = 104,  /// encoding according to RFC 1922 (Chinese Character Encoding)
  charset_gb_2312  = 2025  /// encoding according to Chinese Graphic
};

//=============================================================================
typedef BITS16 StringFlags;  /// @see StringFlagsBits

enum StringFlagsBits
{
  str_flag_nt  = 0x1  // 0  /// strings are null terminated
};

//=============================================================================
struct StringSpec
{
  INTU16 str_max_len;
  StringFlags str_flags;
}; //@top-level false

//=============================================================================
/**
 * Locale data type.
 * Use the locale data type to specify language and encoding information for
 * data types that represent human-readable text strings.
 */
struct Locale
{
  INTU32  language;
  INTU32  country;
  CharSet charset;
  StringSpec str_spec;
}; //@top-level false

//=============================================================================
/**
 * Alert-Op-State attribute defines the current limit alert state
 * NOTE--The bits refer to the limit alarm only, not to the global alert
 * state of the metric
 */
typedef BITS16 CurLimAlStat;  /// @see CurLimAlStatBits

enum CurLimAlStatBits
{
  lim_alert_off = 0x1, // 0,  /// if this bit set all alerts (both high, low) are off
  lim_low_off   = 0x2, // 1,  /// low-limit violation detection is off
  lim_high_off  = 0x4  // 2   /// high-limit violation detection is off
};

//=============================================================================
/**
 * Current-Limits attribute
 */
struct CurLimAlVal
{
  FLOATType lower;
  FLOATType upper;
}; //@top-level false

//=============================================================================
/**
 * Top object.
 * The Top object is the common inheritance base for all objects in the DIM.
 */
struct DIMT_Top
{
  /// Define the ID of the class.
  /// IDs come from the object-oriented nomenclature partition.
  OIDType  class_id;

  /// Define ID of Name Binding attribute, e.g., DIMHANDLE.
  /// IDs come from the object-oriented nomenclature partition.
  OIDType  name_binding_id;
}; //@top-level false

//=============================================================================
/**
 * Virtual Medical Object (VMO).
 * The VMO is the base class for all medical-related objects in the model.
 * The VMO provides consistent naming and identification across the Medical
 * Package model.
 */
struct DIMT_VMO
{
  DIMT_Top top;

  /// Define a specific static type of this object, as defined in the
  /// object-oriented or metric nomenclature partition.
  TTYPE object_type;

  /// Locally unique short-hand identification.
  DIMHANDLE dimhandle;

  /// Text representation of type ID.
  CHARSTRING label_string[MAXSTRSIZE_LABEL];
}; //@top-level false

//=============================================================================
/**
 * MetricStatus and MeasurementStatus are used in several medical package objs.
 * Maybe define these in a separate file?
 */

/**
 * Metric-Status
 */
typedef BITS16 MetricStatus;   /// @see MetricStatusBits

enum MetricStatusBits
{
  metric_off  = 0x1,  // 0,
  metric_not_ready  = 0x2,  // 1,
  metric_standby  = 0x4,    // 2,
  metric_transduc_discon  = 0x100,  // 8,
  metric_hw_discon  = 0x200 // 9
};

/**
 * MeasurementStatus defines the state of the measurement
 */
typedef BITS16 MeasurementStatus;    /// @see MeasurementStatusBits.

enum MeasurementStatusBits
{
  ms_invalid              = 0x01,   // 0,
  ms_questionable         = 0x02,   // 1,
  ms_unavailable          = 0x04,   // 2,
  ms_calibration_ongoing  = 0x08,   // 3,
  ms_test_data            = 0x10,   // 4,
  ms_demo_data            = 0x20,   // 5,
  ms_validated_data       = 0x100,  // 8,   /// relevant, e.g., in an archive
  ms_early_indication     = 0x200,  // 9,   /// early estimate of value
  ms_msmt_ongoing         = 0x400,  // 10,  /// new measurement is being taken
  ms_msmt_in_state_alarm  = 0x4000, // 14,  /// metric has active alarm cond

  /// metric supports alarming, and alarms are turned off
  ms_msmt_state_al_inhibited = 0x8000 // 15
};
};
};
};
};
#endif /* _DIM_BASE_TYPES_IDL_ */
